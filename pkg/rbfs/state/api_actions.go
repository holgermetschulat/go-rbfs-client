/*
 * RBFS Operational State API
 *
 * This contract describes the RBFS Operational State API contract defined by RBMS, the RtBrick Management System. This API is a _consumer-driven_ API, which means that all changes to this API **must be approved** by RBMS, the consumer of this API to avoid compatibility issues.  The API is kept backwards-compatible and anyone is allowed to _use_ this API.  The consumer of the API _must_ ignore additional attributes not explained in this specification. Additional attributes are _not_ considered violating backwards compatibility. In contrary, additional attributes allow extending the API while preserving backward compatibility.
 *
 * API version: 1.0.0
 * Contact: martin@rtbrick.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package state

import (
	"context"
	"github.com/antihax/optional"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type ActionsApiService service

/*
ActionsApiService Pings the given destination IP address.
Pings the given IPv4 or IPv6 destination IP address  from the specified source IP or source IFL with the provided settings.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param destinationIp Destination IPv4 or IPv6 address
 * @param optional nil or *ActionsApiActionsPingPostOpts - Optional Parameters:
     * @param "SourceIp" (optional.String) -  Source IPv4 or IPv6 address
     * @param "SourceIfl" (optional.String) -  Source interface name.
     * @param "InstanceName" (optional.String) -  Routing instance name
     * @param "Count" (optional.Int32) -  Number of pings.
     * @param "Interval" (optional.Float32) -  Ping interval in seconds.
     * @param "Size" (optional.Int32) -  Packet payload size in bytes.
     * @param "Ttl" (optional.Int32) -  IP TTL value
@return PingStatus
*/

type ActionsApiActionsPingPostOpts struct {
	SourceIp     optional.String
	SourceIfl    optional.String
	InstanceName optional.String
	Count        optional.Int32
	Interval     optional.Float32
	Size         optional.Int32
	Ttl          optional.Int32
}

func (a *ActionsApiService) ActionsPingPost(ctx context.Context, destinationIp string, localVarOptionals *ActionsApiActionsPingPostOpts) (PingStatus, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue PingStatus
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/actions/ping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("destination_ip", parameterToString(destinationIp, ""))
	if localVarOptionals != nil && localVarOptionals.SourceIp.IsSet() {
		localVarQueryParams.Add("source_ip", parameterToString(localVarOptionals.SourceIp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourceIfl.IsSet() {
		localVarQueryParams.Add("source_ifl", parameterToString(localVarOptionals.SourceIfl.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InstanceName.IsSet() {
		localVarQueryParams.Add("instance_name", parameterToString(localVarOptionals.InstanceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Interval.IsSet() {
		localVarQueryParams.Add("interval", parameterToString(localVarOptionals.Interval.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ttl.IsSet() {
		localVarQueryParams.Add("ttl", parameterToString(localVarOptionals.Ttl.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/josn"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v PingStatus
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ActionsApiService Traces the route to the given destination IP address.
Traces the route to the given IPv4 or IPv6 destination IP address  from the specified source IP or source IFL with the provided settings.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param destinationIp Destination IPv4 or IPv6 address
 * @param optional nil or *ActionsApiActionsTraceroutePostOpts - Optional Parameters:
     * @param "SourceIp" (optional.String) -  Source IPv4 or IPv6 address
     * @param "SourceIfl" (optional.String) -  Source interface name.
     * @param "InstanceName" (optional.String) -  Routing instance name
     * @param "MaxHops" (optional.Int32) -  Maximum number of acceptable hops to reach the given destination.
     * @param "Size" (optional.Int32) -  Packet payload size in bytes.
     * @param "Interval" (optional.Float32) -  Ping interval in seconds.
@return Traceroute
*/

type ActionsApiActionsTraceroutePostOpts struct {
	SourceIp     optional.String
	SourceIfl    optional.String
	InstanceName optional.String
	MaxHops      optional.Int32
	Size         optional.Int32
	Interval     optional.Float32
}

func (a *ActionsApiService) ActionsTraceroutePost(ctx context.Context, destinationIp string, localVarOptionals *ActionsApiActionsTraceroutePostOpts) (Traceroute, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Post")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue Traceroute
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/actions/traceroute"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("destination_ip", parameterToString(destinationIp, ""))
	if localVarOptionals != nil && localVarOptionals.SourceIp.IsSet() {
		localVarQueryParams.Add("source_ip", parameterToString(localVarOptionals.SourceIp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourceIfl.IsSet() {
		localVarQueryParams.Add("source_ifl", parameterToString(localVarOptionals.SourceIfl.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InstanceName.IsSet() {
		localVarQueryParams.Add("instance_name", parameterToString(localVarOptionals.InstanceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxHops.IsSet() {
		localVarQueryParams.Add("max_hops", parameterToString(localVarOptionals.MaxHops.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Interval.IsSet() {
		localVarQueryParams.Add("interval", parameterToString(localVarOptionals.Interval.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/josn"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Traceroute
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
